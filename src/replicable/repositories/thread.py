import uuid
from collections import OrderedDict
from typing import Optional, List, Tuple

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from replicable.models.thread import Thread
from replicable.models.message import Message
from replicable.models.user import User

__all__ = [
    "get_by_id",
    "get_user",
    "list_messages_per_thread",
    "list_message_counts",
    "create",
]


async def get_by_id(session: AsyncSession, thread_id: uuid.UUID) -> Optional[Thread]:
    """Return a single thread by its id or None if not found."""
    result = await session.execute(select(Thread).where(Thread.id == thread_id))
    return result.scalar_one_or_none()


async def get_user(session: AsyncSession, thread_id: uuid.UUID) -> Optional[User]:
    """Return the owning User for a given thread id.

    Returns None if the thread (or its user) does not exist.
    Executes a single joined query.
    """
    stmt = (
        select(User)
        .join(Thread, Thread.user_id == User.id)
        .where(Thread.id == thread_id)
        .limit(1)
    )
    res = await session.execute(stmt)
    return res.scalar_one_or_none()


async def create(
    session: AsyncSession,
    *,
    title: str,
    user_id: uuid.UUID,
    id: uuid.UUID | None = None,
) -> Thread:
    """Create a new Thread.

    Parameters:
        session: active AsyncSession.
        title: thread title (must be unique per DB constraints).
        user_id: owning user's UUID.
        id: optional explicit UUID (else auto-generated by ORM default).

    Returns the persisted Thread (flushed, not committed).
    """
    thread = Thread(title=title, user_id=user_id, **({"id": id} if id else {}))
    session.add(thread)
    # flush so that constraints (like uniqueness) are checked early and id is available
    await session.flush()
    return thread


async def list_messages_per_thread(
    session: AsyncSession, thread_id: uuid.UUID | None = None
) -> List[Tuple[Thread, List[Message]]]:
    """List all messages per thread.

    Returns a list of (Thread, [Message, ...]) tuples. Threads with no messages
    will have an empty list. If thread_id is provided, only that thread is returned.
    Messages are ordered by created timestamp (oldest first).
    """
    stmt = (
        select(Thread, Message)
        .outerjoin(Message, Message.thread_id == Thread.id)
        .order_by(Thread.id, Message.created.asc())
    )
    if thread_id:
        stmt = stmt.where(Thread.id == thread_id)

    res = await session.execute(stmt)

    # create returned object
    grouped: "OrderedDict[uuid.UUID, Tuple[Thread, List[Message]]]" = OrderedDict()
    for thread_obj, message_obj in res.all():  # type: ignore
        if thread_obj.id not in grouped:
            grouped[thread_obj.id] = (thread_obj, [])
        if message_obj is not None:
            grouped[thread_obj.id][1].append(message_obj)

    return list(grouped.values())


async def list_message_counts(session: AsyncSession) -> List[Tuple[Thread, int]]:
    """List threads with their message counts.

    Returns a list of (Thread, count) tuples.
    """
    stmt = (
        select(Thread, func.count(Message.id).label("message_count"))
        .outerjoin(Message, Message.thread_id == Thread.id)
        .group_by(Thread.id)
    )
    res = await session.execute(stmt)
    return [(row[0], row[1]) for row in res.all()]

